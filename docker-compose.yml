version: '3.8'

#
# x-** are dummy mapping directives.
# only used for yaml anchors to
# DRY out the compose file
x-app-volumes: &volumes
  volumes:
    # This mounts the current working directory into the docker container
    - .:/app
    # These are things that change a lot and have to be synced with the host fs
    # If you're running Linux, this is a non-issue. Docker for Mac has significant
    # performance issues with file IO between host (docker) and the system.
    # adding volumes for problem areas is one way to work around the situation
    - gem_cache:/bundle/vendor
    - node_modules:/app/node_modules
    - packs:/app/public/packs
    - packs_test:/app/public/packs-test

services:
  #
  # External Services
  #
  db:
    # At the time of this writing Postgres 13 is the latest.
    image: postgres:13
    restart: on-failure

    volumes:
      - pg_data:/var/lib/postgresql/data
      # allows us to dump the database somewhere e.g.:
      # pg_dump -U $POSTGRES_USER -F t $POSTGRES_DB > /backups/$POSTGRES_DB-$(date +%Y-%m-%d).tar'
      - ./db/dumps:/backups

    environment:
      # Postres docker containers are configured via env vars.
      - POSTGRES_PASSWORD=letmein
      - POSTGRES_USER=myuser
      - POSTGRES_DB=appdb

    networks:
      # The "backend" network are supporting services that are not the app server, or not part of the HTTP layer.
      - backend

    ports:
      # I like to expose "system" services on a different port, in case there is already an instance of pgsql running
      # on the host machine. By doing this, postgres can be reached from localhost at port 5433.
      - '5433:5432'
  #
  # App services
  #
  web:
    # this command starts a rails server and listens on all interfaces (0.0.0.0)
    command: bash -c "rm -f /app/tmp/pids/server.pid && rails s -p 3000 -b '0.0.0.0'"

    restart: on-failure

    # We have the option of adding an `environment:` yaml key here as well, but I prefer using an env file
    # to keep things cleaner.
    env_file: .env.docker.development

    # This builds the image as "appimage" so that we can refer to it later in this file.
    image: appimage
    build:
      context: ./
      dockerfile: Dockerfile

    <<: *volumes
    networks:
      - frontend
      - backend
    ports:
      - '3000:3000'

    # These declarations allow a pry session to be attatched if desired.
    tty: true
    stdin_open: true

  webpacker:
    command: ./bin/webpack-dev-server
    restart: on-failure
    env_file: .env.docker.development

    # This is the app image we built in 'web'
    image: appimage

    # It's allowed to have both an .env file AND environment defined.
    # when in doubt, refer to this: https://docs.docker.com/compose/environment-variables/
    # This bit of configuration is critical
    # to the proper operation of webpack-dev-server, so I like to define it here.
    environment:
      - WEBPACKER_DEV_SERVER_HOST=0.0.0.0

    <<: *volumes

    # We don't need to connect to the DB at all here, so we just add the frontend network
    networks:
      - frontend

    # allows webpack-dev-server to be accessed at localhost:3035
    ports:
      - '3035:3035'

  #
  # Testing
  # To use: docker-compose exec rspec '/path/to/spec'
  #
  test:
    image: appimage
    env_file: .env.docker.test

    # This does two things... Allows our test container to be persistent, and loads the test boilerplate
    # for faster test runs. You need the "spring-commands-rspec" installed in order to make this work (assuming you're using rspec)
    command: bin/spring server

    # This is a different env file, for testing only.
    env_file: .env.docker.test

    # We don't need to allow access to the app at all during testing, so it's a backend service
    networks:
      - backend

    <<: *volumes

# Our network declarations, used in
networks:
  frontend:
  backend:

volumes:
  pg_data:
  gem_cache:
  node_modules:
  packs:
  packs_test:
